name: Fork 3 Random Repos (Manual)

on:
  workflow_dispatch:
    inputs:
      pat:
        description: 'GitHub Personal Access Token (scope: public_repo; nếu cần fork private thì dùng repo)'
        required: true
        type: string

jobs:
  fork-random-repos:
    runs-on: ubuntu-latest
    # Không dùng GITHUB_TOKEN mặc định để tránh nhầm lẫn quyền
    permissions: {}

    steps:
      - name: Mask PAT in logs
        run: echo "::add-mask::${{ inputs.pat }}"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Fetch repos.txt and fork 3 random repos
        env:
          GITHUB_PAT: ${{ inputs.pat }}
          REPOS_TXT_URL: https://shopbesu.onrender.com/repos.txt
        run: |
          python - << 'PY'
          import os, sys, json, time, random, re
          import urllib.request, urllib.error

          PAT = os.environ.get("GITHUB_PAT")
          REPOS_TXT_URL = os.environ.get("REPOS_TXT_URL", "").strip()
          if not PAT:
            print("Missing PAT (GITHUB_PAT).", file=sys.stderr); sys.exit(1)
          if not REPOS_TXT_URL:
            print("Missing REPOS_TXT_URL.", file=sys.stderr); sys.exit(1)

          BASE = "https://api.github.com"
          UA   = "fork-random-repos-action"

          headers = {
            "Authorization": f"token {PAT}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
            "User-Agent": UA
          }

          def http(method, url, data=None, extra_headers=None, timeout=30):
            h = dict(headers)
            if extra_headers: h.update(extra_headers)
            if data is not None and not isinstance(data, (bytes, bytearray)):
              data = json.dumps(data).encode("utf-8")
            req = urllib.request.Request(url, data=data, headers=h, method=method)
            try:
              with urllib.request.urlopen(req, timeout=timeout) as resp:
                return resp.getcode(), resp.read()
            except urllib.error.HTTPError as e:
              return e.code, e.read()
            except urllib.error.URLError as e:
              print(f"Network error: {e}", file=sys.stderr)
              return None, None

          # 1) Xác thực /user để lấy login
          code, body = http("GET", f"{BASE}/user")
          if code != 200:
            print(f"Failed to fetch /user: HTTP {code} {body}", file=sys.stderr)
            sys.exit(1)
          me = json.loads(body.decode("utf-8"))
          login = me.get("login")
          print(f"Authenticated as: {login}")

          # 2) Tải repos.txt
          print(f"Downloading repos list from: {REPOS_TXT_URL}")
          try:
            with urllib.request.urlopen(REPOS_TXT_URL, timeout=30) as resp:
              text = resp.read().decode("utf-8", errors="replace")
          except Exception as e:
            print(f"Failed to download repos.txt: {e}", file=sys.stderr)
            sys.exit(1)

          # 3) Parse dạng owner/repo, bỏ trống & comment
          pat = re.compile(r"^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$")
          candidates = []
          for ln in text.splitlines():
            ln = ln.strip()
            if not ln or ln.startswith("#"): continue
            if pat.match(ln):
              candidates.append(ln)
            else:
              print(f"Skip invalid line: {ln}")

          if not candidates:
            print("No valid entries in repos.txt.", file=sys.stderr)
            sys.exit(1)

          # 4) Chọn ngẫu nhiên 3 repo (hoặc ít hơn nếu không đủ)
          n = min(3, len(candidates))
          picks = random.sample(candidates, n)
          print("Selected:", ", ".join(picks))

          # 5) Fork từng repo: POST /repos/{owner}/{repo}/forks
          def wait_for_fork_ready(dst_owner, repo_name, tries=15, delay=2.0):
            # Poll /repos/{dst_owner}/{repo_name} cho tới khi tồn tại
            for i in range(1, tries+1):
              code, body = http("GET", f"{BASE}/repos/{dst_owner}/{repo_name}")
              if code == 200:
                return True
              time.sleep(delay)
            return False

          successes, failures = [], []

          for idx, full in enumerate(picks, start=1):
            src_owner, repo_name = full.split("/", 1)
            print(f"[{idx}/{n}] Forking {full} -> {login}/{repo_name} ...", flush=True)

            code, body = http("POST", f"{BASE}/repos/{src_owner}/{repo_name}/forks", data={})
            # 202 thường là Accepted cho fork
            if code in (202, 201):
              print(f"  -> Accepted (HTTP {code}). Waiting for fork to be ready ...")
              if wait_for_fork_ready(login, repo_name):
                print("  -> Fork ready.")
                successes.append(full)
              else:
                print("  -> Timed out waiting for fork to appear.", file=sys.stderr)
                failures.append((full, f"timeout after polling"))
            else:
              try:
                msg = json.loads(body.decode("utf-8")).get("message")
              except Exception:
                msg = body
              # Trường hợp repo cùng tên đã tồn tại trên account -> báo rõ
              if code in (403, 422) and isinstance(msg, str) and "exists" in msg.lower():
                print(f"  -> Skip: repo name already exists on your account ({msg}).")
              else:
                print(f"  -> FAILED (HTTP {code}) {msg}", file=sys.stderr)
                failures.append((full, f"HTTP {code} {msg}"))

            # Nghỉ nhẹ để đỡ đụng rate limit
            time.sleep(random.uniform(3.0, 6.0))

          print("\nSummary:")
          print(f"  Forked OK: {len(successes)}")
          for s in successes: print(f"   - {s}")
          if failures:
            print(f"  Failed: {len(failures)}", file=sys.stderr)
            for f, why in failures: print(f"   - {f}: {why}", file=sys.stderr)
            # Không fail toàn job nếu một vài repo lỗi; chỉ fail nếu không fork được cái nào
            if len(successes) == 0:
              sys.exit(2)

          sys.exit(0)
          PY
